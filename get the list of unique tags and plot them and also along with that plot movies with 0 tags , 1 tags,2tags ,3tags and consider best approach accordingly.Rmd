---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
install.packages("dplyr")
install.packages("ggplot2")
```
```{r}
setwd("C:/DMP/datamining project/")
library(dplyr)
library(ggplot2)
movies <- read.csv("C:/DMP/datamining project/movie.csv", stringsAsFactors = FALSE)
tags <- read.csv("C:/DMP/datamining project/tag.csv", stringsAsFactors = FALSE)
# View the first few rows of the movies dataset
head(movies)

# View the first few rows of the tags dataset
head(tags)
# Convert all tags to lowercase
tags$tag <- tolower(tags$tag)

# Check the changes by displaying a few rows
head(tags$tag)
# Extract unique tags after converting to lowercase
unique_tags <- unique(tags$tag)

# Display the number of unique tags
length(unique_tags)

# Preview the first few unique tags
head(unique_tags)
# Count the frequency of each tag
tag_frequency <- as.data.frame(table(tags$tag))
colnames(tag_frequency) <- c("tag", "frequency")

# Sort the tags by frequency in descending order
tag_frequency <- tag_frequency[order(-tag_frequency$frequency), ]

# Plot the top 20 most common tags
library(ggplot2)
ggplot(tag_frequency[1:20,], aes(x = reorder(tag, -frequency), y = frequency)) +
  geom_bar(stat = "identity", fill = "darkgreen") +
  coord_flip() +
  labs(title = "Top 20 Most Common Tags", x = "Tag", y = "Frequency") +
  theme_minimal()
# Calculate the number of tags per movie
movie_tag_counts <- tags %>%
  group_by(movieId) %>%
  summarise(tag_count = n())

# Merge with the 'movies' dataset to include movies with 0 tags
movies_with_tags <- movies %>%
  left_join(movie_tag_counts, by = "movieId") %>%
  mutate(tag_count = ifelse(is.na(tag_count), 0, tag_count))

# Create a summary table of the number of movies by tag count
tag_count_summary <- movies_with_tags %>%
  group_by(tag_count) %>%
  summarise(movie_count = n())

# Plot a bar graph of the number of movies based on tag count
ggplot(tag_count_summary, aes(x = tag_count, y = movie_count)) +
  geom_bar(stat = "identity", fill = "skyblue", color = "darkblue") +
  labs(title = "Number of Movies by Tag Count",
       x = "Number of Tags",
       y = "Number of Movies") +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, max(tag_count_summary$tag_count), by = 1)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
###AGGREGATING TO BINS TO SEE IF VISUALIZATION IMPROVES 
# Create bins for tag counts
movies_with_tags$tag_bin <- cut(
  movies_with_tags$tag_count,
  breaks = c(-1, 0, 1, 5, 10, 20, 50, Inf),
  labels = c("0", "1", "2-5", "6-10", "11-20", "21-50", "50+"),
  right = TRUE
)

# Create a summary table of the number of movies by tag bin
tag_bin_summary <- movies_with_tags %>%
  group_by(tag_bin) %>%
  summarise(movie_count = n())

# Plot the number of movies per tag bin
library(ggplot2)
ggplot(tag_bin_summary, aes(x = tag_bin, y = movie_count)) +
  geom_bar(stat = "identity", fill = "lightgreen", color = "darkgreen") +
  labs(title = "Distribution of Movies Based on Number of Tags (Binned)",
       x = "Number of Tags (Binned)",
       y = "Number of Movies") +
  theme_minimal() +
  geom_text(aes(label = movie_count), vjust = -0.5, size = 3.5)
###Checking for log scale option too 
ggplot(tag_count_summary, aes(x = tag_count, y = movie_count)) +
  geom_bar(stat = "identity", fill = "skyblue", color = "darkblue") +
  scale_y_log10() +
  labs(title = "Number of Movies by Tag Count (Log Scale)",
       x = "Number of Tags",
       y = "Number of Movies (Log Scale)") +
  theme_minimal()
####CREATING A USER TAG INTERACTION MATRIX

library(dplyr)
library(tidyr)

# Count the number of times each user has used each tag
user_tag_counts <- tags %>%
  group_by(userId, tag) %>%
  summarise(tag_frequency = n()) %>%
  ungroup()

# Step 2: Create a sparse user-tag matrix
user_tag_matrix <- user_tag_counts %>%
  pivot_wider(names_from = tag, values_from = tag_frequency, values_fill = 0)

# Preview the user-tag matrix
head(user_tag_matrix[, 1:10])

###CREATING A MOVIE TAG MATRIX 
#  movie-tag interaction matrix
movie_tag_counts <- tags %>%
  group_by(movieId, tag) %>%
  summarise(tag_frequency = n()) %>%
  ungroup()

# Step 2: Create a sparse movie-tag matrix
movie_tag_matrix <- movie_tag_counts %>%
  pivot_wider(names_from = tag, values_from = tag_frequency, values_fill = 0)

# Preview the movie-tag matrix
head(movie_tag_matrix[, 1:10])
### calculating similarity scores 
# Load necessary library
library(proxy)
# Identify top 100 most common tags with `.groups = "drop"`
top_tags <- tags %>%
  group_by(tag) %>%
  summarise(frequency = n(), .groups = "drop") %>%
  arrange(desc(frequency)) %>%
  slice_head(n = 100) %>%
  pull(tag)

# Filter the movie-tag matrix to include only top 100 tags
filtered_movie_tag_matrix <- movie_tag_matrix %>%
  select(movieId, all_of(top_tags))

# Convert to a numeric matrix explicitly using `base::as.matrix()`
filtered_movie_tag_matrix_numeric <- base::as.matrix(filtered_movie_tag_matrix[, -1])
rownames(filtered_movie_tag_matrix_numeric) <- filtered_movie_tag_matrix$movieId
# Load the proxy library and handle function masking
library(proxy)

# Calculate cosine similarity using the reduced matrix
movie_similarity <- proxy::simil(filtered_movie_tag_matrix_numeric, method = "cosine")

# Convert to a data frame for ease of use
movie_similarity_df <- as.data.frame(base::as.matrix(movie_similarity))
colnames(movie_similarity_df) <- filtered_movie_tag_matrix$movieId
rownames(movie_similarity_df) <- filtered_movie_tag_matrix$movieId

# Preview the similarity matrix
head(movie_similarity_df[, 1:5])















```
```{r}
# Function to get top N similar movies based on cosine similarity
get_similar_movies <- function(movie_id, similarity_matrix, top_n = 5) {
  # Extract similarity scores for the given movie_id as a numeric vector
  similarity_scores <- as.numeric(similarity_matrix[movie_id, ])
  names(similarity_scores) <- colnames(similarity_matrix)
  
  # Remove the movie itself from the recommendations
  similarity_scores[movie_id] <- NA
  
  # Sort similarity scores in descending order and get top N similar movies
  top_movies <- head(sort(similarity_scores, decreasing = TRUE, na.last = TRUE), top_n)
  
  # Create a data frame of top similar movie IDs and their similarity scores
  similar_movies <- data.frame(movieId = names(top_movies), similarity = top_movies)
  
  # Convert movieId to numeric for easier handling
  similar_movies$movieId <- as.numeric(as.character(similar_movies$movieId))
  
  return(similar_movies)
}

# Example: Get top 5 similar movies for a given movieId (e.g., movieId = "1")
top_similar_movies <- get_similar_movies(movie_id = "1", similarity_matrix = movie_similarity_df, top_n = 5)
print(top_similar_movies)


```
```{r}
# Function to create a user profile vector based on tag usage
create_user_profile <- function(user_id, user_tag_matrix) {
  # Extract the tag usage for the specific user
  user_profile <- user_tag_matrix[user_tag_matrix$userId == user_id, -1]
  
  # Aggregate the tag frequencies across all tagged movies by the user
  user_profile_vector <- colSums(user_profile)
  
  # Normalize the profile vector (optional)
  user_profile_vector <- user_profile_vector / sum(user_profile_vector)
  
  return(user_profile_vector)
}

# Example: Create a user profile for userId = 65
user_profile <- create_user_profile(user_id = 65, user_tag_matrix = user_tag_matrix)
print(user_profile)

```
```{r}
 # Function to recommend movies based on user profile
recommend_movies <- function(user_profile, movie_tag_matrix, top_n = 10) {
  # Ensure movie_tag_matrix is a data frame
  movie_tag_matrix <- as.data.frame(movie_tag_matrix)
  
  # Select only tag columns (excluding movieId column
  tag_columns <- colnames(movie_tag_matrix)[-1]
  
  # Ensure user profile has the same order and length as the movie tag matrix
  user_profile <- user_profile[tag_columns]
  
  # Check if dimensions match between user profile and tag columns
  if (length(user_profile) != length(tag_columns)) {
    stop("Mismatch in dimensions between user profile and movie tag matrix.")
  }
  
  # Calculate similarity scores using matrix multiplication
  movie_scores <- as.numeric(as.matrix(movie_tag_matrix[, tag_columns]) %*% user_profile)
  
  # Check if movie_scores is empty or contains only zeros or NAs
  if (all(is.na(movie_scores)) || sum(movie_scores == 10) == length(movie_scores)) {
    cat("Warning: No valid movie scores computed. All scores are NA or zero.\n")
    return(data.frame(movieId = numeric(10), score = numeric(10)))  # Return empty if no scores
  }
  
  # Get movieId column (assuming it is the first column in the matrix)
  movie_ids <- movie_tag_matrix$movieId
  
  # Assign movie IDs to the scores
  names(movie_scores) <- movie_ids
  
  # Sort movies based on scores and get top N recommendations
  sorted_scores <- sort(movie_scores, decreasing = TRUE)
  
  # Handle the case where there are less than top_n valid movies
  top_recommendations <- head(sorted_scores, top_n)
  
  # If no valid recommendations are found, return an empty data frame
  if (length(top_recommendations) == 0) {
    cat("Warning: No recommendations found.\n")
    return(data.frame(movieId = numeric(0), score = numeric(0)))  # Return empty data frame
  }
  
  # Create a data frame of recommendations
  recommended_movies <- data.frame(movieId = as.numeric(names(top_recommendations)), score = top_recommendations)
  
  return(recommended_movies)
}

# Example usage:
# Assuming `user_profile` is created using the function `create_user_profile`
user_profile <- create_user_profile(user_id = 65, user_tag_matrix)
recommendations <- recommend_movies(user_profile, filtered_movie_tag_matrix_numeric, top_n = 10)

# Print the recommendations
print(recommendations)



```




Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
